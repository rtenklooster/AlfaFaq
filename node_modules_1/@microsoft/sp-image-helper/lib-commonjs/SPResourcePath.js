"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._SPResourcePath = exports._SPResourcePathFormat = void 0;
var UPPER_CASE_ENCODING_REGEXP = new RegExp(/(\%[0-9][A-F])|(\%[A-F][0-9])|(\%[A-F][A-F])/g);
var LOWER_CASE_ENCODING_REGEXP = new RegExp(/(\%[0-9][a-f])|(\%[a-f][0-9])|(\%[a-f][a-f])/g);
/**
 * @internal
 */
var _SPResourcePathFormat;
(function (_SPResourcePathFormat) {
    _SPResourcePathFormat[_SPResourcePathFormat["absolute"] = 0] = "absolute";
    _SPResourcePathFormat[_SPResourcePathFormat["relative"] = 1] = "relative";
    _SPResourcePathFormat[_SPResourcePathFormat["serverRelative"] = 2] = "serverRelative";
})(_SPResourcePathFormat = exports._SPResourcePathFormat || (exports._SPResourcePathFormat = {}));
/**
 * Simplified implementation of a URI parser which does not attempt decoding of segments,
 * handling of query strings, or separation of the fragment. Intended for use on SharePoint
 * Resource Paths or other URL-like entities which may not actually conform to the URL
 * specification, but may be used for simple transformations of URLs.
 *
 * This class makes several assumptions about the format of input URLs:
 * - Absolute URLs begin with '<scheme>://<host>'
 * - Relative URLs being with '/'
 * - URLs never have a trailing '/'
 *
 * @internal
 */
// tslint:disable-next-line:class-name export-name
var _SPResourcePath = /** @class */ (function () {
    /**
     * Creates an instance of SPResourcePath.
     *
     * @param value - A string representing a well-formed, decoded SharePoint resource path.
     * @param relativePath - An optional, decoded path to be appended to the first parameter.
     */
    function _SPResourcePath(value, relativePath) {
        if (value === void 0) { value = ''; }
        var rootDelimeter = '//';
        var searchDelimiter = '?';
        if (relativePath) {
            if (value[value.length - 1] === '/' && relativePath[0] === '/') {
                value = value + relativePath.slice(1);
            }
            else if (value[value.length - 1] !== '/' && relativePath[0] !== '/') {
                value = value + '/' + relativePath;
            }
            else {
                value = value + relativePath;
            }
        }
        var indexOfRootDelimeter = value.indexOf(rootDelimeter);
        var indexOfPathDelimeter = value.indexOf('/');
        var indexOfSearchDelimeter = value.indexOf(searchDelimiter);
        // The root delimeter is the first instance of '//', unless preceded by a lone '/'
        var endIndexOfRootDelimeter = indexOfRootDelimeter > -1 && indexOfRootDelimeter <= indexOfPathDelimeter
            ? indexOfRootDelimeter + rootDelimeter.length
            : -1;
        var authority = getAuthority(value, endIndexOfRootDelimeter);
        var domain = authority && authority.slice(endIndexOfRootDelimeter);
        var host = domain && domain.split(':')[0];
        // By definition, everything after the authority is the path
        var path = indexOfSearchDelimeter > 0
            ? value.slice(authority.length, indexOfSearchDelimeter)
            : value.slice(authority.length);
        var format = authority
            ? _SPResourcePathFormat.absolute
            : path[0] === '/'
                ? _SPResourcePathFormat.serverRelative
                : _SPResourcePathFormat.relative;
        var segments = path.split('/');
        this._originalSearchString = indexOfSearchDelimeter > 0 ? value.slice(indexOfSearchDelimeter) : '';
        this.searchParams = new URLSearchParams(this._originalSearchString);
        this.authority = authority;
        this.domain = domain;
        this.host = host;
        this.format = format;
        this.path = path;
        this.segments = segments;
        this.value = value;
    }
    _SPResourcePath._getTenantInfoFromPageContext = function (pageContext) {
        return pageContext
            ? {
                isMultiGeo: pageContext.legacyPageContext.isMultiGeoTenant,
                multiGeoInfo: pageContext.legacyPageContext.multiGeoInfo,
                singleTenant: pageContext.legacyPageContext.vanityUrls
            }
            : undefined;
    };
    _SPResourcePath._getHostFromUrl = function (url) {
        return url ? new _SPResourcePath(url).domain : url;
    };
    _SPResourcePath._getMySiteAndPortalDomain = function () {
        var mySiteSuffix = '-my';
        var currentDomain = "".concat(window.location.protocol, "//").concat(window.location.hostname);
        var tenantName = window.location.hostname.substr(0, window.location.hostname.indexOf('.'));
        if (tenantName.indexOf(mySiteSuffix, tenantName.length - mySiteSuffix.length) === -1) {
            var mySiteHostDomain = currentDomain
                .toString()
                .replace(tenantName, tenantName + mySiteSuffix);
            return [mySiteHostDomain, currentDomain];
        }
        else {
            var portalDomain = currentDomain
                .toString()
                .replace(tenantName, tenantName.substring(0, tenantName.length - mySiteSuffix.length));
            return [currentDomain, portalDomain];
        }
    };
    /**
     * Create a single string that includes the query/search parameters
     */
    _SPResourcePath.prototype.toString = function () {
        return this.authority + this.path + this.searchParamString;
    };
    /**
     * Compare against another SPResourcePath. The comparison will assume
     * query/search parameters are in the same order
     */
    _SPResourcePath.prototype.equals = function (value) {
        return value && this.toString() === value.toString();
    };
    /**
     * True if url is internal resource.
     */
    _SPResourcePath.prototype.isInternalResource = function (pageContext) {
        var _this = this;
        var tenantInfo = _SPResourcePath._getTenantInfoFromPageContext(pageContext);
        // Vanity urls are saved in different places with different format in page context
        // according to whether the tenant is multi-geo or not.
        // In multi-geo tenant, vanity urls is saved in AdditionalUrls in multiGeoInfo.
        // In non multi-geo tenant, vanity urls are saved in VanityUrls.
        try {
            if ((tenantInfo === null || tenantInfo === void 0 ? void 0 : tenantInfo.isMultiGeo) && (tenantInfo === null || tenantInfo === void 0 ? void 0 : tenantInfo.multiGeoInfo)) {
                return tenantInfo.multiGeoInfo.some(function (geoInfo) {
                    return (_this._isSameHost(geoInfo.PortalUrl) ||
                        _this._isSameHost(geoInfo.MySiteHostUrl) ||
                        _this._isSameHosts(geoInfo.AdditionalUrls));
                });
            }
            else {
                // Use vanity urls combined with current Geo info in non multiGeo tenant.
                var currentGeoDomains = _SPResourcePath._getMySiteAndPortalDomain();
                if (this._isSameHosts(currentGeoDomains)) {
                    return true;
                }
                if ((tenantInfo === null || tenantInfo === void 0 ? void 0 : tenantInfo.singleTenant) && (tenantInfo === null || tenantInfo === void 0 ? void 0 : tenantInfo.singleTenant.SingleTenant_AdditionalVanityUrls)) {
                    var vanityHosts = tenantInfo.singleTenant.SingleTenant_AdditionalVanityUrls.split(';');
                    if (vanityHosts.indexOf(this.domain) !== -1) {
                        return true;
                    }
                }
                if ((tenantInfo === null || tenantInfo === void 0 ? void 0 : tenantInfo.singleTenant) && this._isInternalResourceOfSingleTenant(tenantInfo.singleTenant)) {
                    return true;
                }
            }
        }
        catch (error) {
            return false;
        }
        return false;
    };
    /**
     * Use this method to handle proper decoding of value before setting it.
     *
     * @param key - query param to set
     * @param value - value to set
     */
    _SPResourcePath.prototype.setSearchParam = function (key, value) {
        if (!value) {
            this.searchParams.set(key, value);
        }
        else {
            // For query strings only, "+" is a valid substitute for a space, but decodeURIComponent
            // doesn't take this into account. (Note that replace("+", " ") only replaces one +.)
            this.searchParams.set(key, decodeURIComponent(value.replace(/\+/g, ' ')));
        }
    };
    Object.defineProperty(_SPResourcePath.prototype, "searchParamString", {
        /**
         * Retrieve the search parameters back as a single string. If there are any search parameters,
         * this string will be preceeded with a '?'
         */
        get: function () {
            var _a;
            var toReturn = (_a = this.searchParams.toString()) === null || _a === void 0 ? void 0 : _a.replace(/\+/g, '%20');
            // If the original search string had lower case encoding, make sure the output
            // also has lower case encoding. The default encoding is upper case.
            if (toReturn && !!this._originalSearchString.match(LOWER_CASE_ENCODING_REGEXP)) {
                toReturn = toReturn.replace(UPPER_CASE_ENCODING_REGEXP, function (encoded) {
                    return encoded === null || encoded === void 0 ? void 0 : encoded.toLowerCase();
                });
            }
            // Make sure to add the query question mark if there is a query param string
            return toReturn ? '?' + toReturn : toReturn;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Helper method to retrieve a query parameter's value
     *
     * @param param - Parameter to return value
     *
     */
    _SPResourcePath.prototype.getQueryParameter = function (param) {
        var _a;
        return (_a = this.searchParams) === null || _a === void 0 ? void 0 : _a.get(param);
    };
    /**
     * Helper method to remove a query parameter
     *
     * @param param - Parameter to remove
     *
     */
    _SPResourcePath.prototype.removeQueryParameter = function (param) {
        var _a;
        (_a = this.searchParams) === null || _a === void 0 ? void 0 : _a.delete(param);
    };
    _SPResourcePath.prototype._isInternalResourceOfSingleTenant = function (singleTenant) {
        return (singleTenant.SingleTenant_OneDriveUrl === this.domain ||
            singleTenant.SingleTenant_PortalUrl === this.domain ||
            singleTenant.SingleTenant_TeamSitesUrl === this.domain);
    };
    _SPResourcePath.prototype._isSameHost = function (targetUrl) {
        return this.domain.toLowerCase() === _SPResourcePath._getHostFromUrl(targetUrl).toLowerCase();
    };
    _SPResourcePath.prototype._isSameHosts = function (targetUrls) {
        var _this = this;
        return !!(targetUrls === null || targetUrls === void 0 ? void 0 : targetUrls.some(function (targetUrl) { return _this._isSameHost(targetUrl); }));
    };
    return _SPResourcePath;
}());
exports._SPResourcePath = _SPResourcePath;
function getAuthority(value, endIndexOfRootDelimeter) {
    if (endIndexOfRootDelimeter > -1) {
        var indexOfNextSegment = value.indexOf('/', endIndexOfRootDelimeter);
        if (indexOfNextSegment > -1) {
            return value.slice(0, indexOfNextSegment);
        }
        else {
            return value;
        }
    }
    else {
        return '';
    }
}
//# sourceMappingURL=SPResourcePath.js.map