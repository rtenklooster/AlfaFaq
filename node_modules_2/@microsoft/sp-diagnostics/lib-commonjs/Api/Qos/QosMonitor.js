"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
// Copyright (c) Microsoft. All rights reserved.
var sp_core_library_2 = require("@microsoft/sp-core-library");
var TraceLogger_1 = tslib_1.__importDefault(require("../Trace/TraceLogger"));
var QosResultType_1 = require("./QosResultType");
var QosLogger_1 = tslib_1.__importDefault(require("./QosLogger"));
var EngagementLogger_1 = tslib_1.__importDefault(require("../Engagement/EngagementLogger"));
var DiagnosticsSettingsManager_1 = tslib_1.__importDefault(require("../../DiagnosticsSettingsManager"));
var Killswitches_1 = require("../../common/Killswitches");
/**
 * Qos logger
 * This class represents the Qos monitor APIs
 *
 * @preapproved @internal
 */
var QosMonitor = /** @class */ (function () {
    /**
     * Creates a QoS monitor (initializes it and logs the start event)
     * @param scenarioName - Unique name of the QoS scenario
     * You will see start tag: SPPages.ScenarioName.Start
     * @param copyToCosmos - Indicate whether this data should be used as Engagement as well, and sent to COSMOS.
     * @param copyToInterana - Indicate whether this data should be used as Engagement as well, and sent to Interana.
     */
    function QosMonitor(scenarioName, copyToCosmos, copyToInterana) {
        var _a;
        if (copyToCosmos === void 0) { copyToCosmos = false; }
        if (copyToInterana === void 0) { copyToInterana = false; }
        this._qosResultTypeValue = (_a = {},
            _a[QosResultType_1.QosResultType.Success] = 'Success',
            _a[QosResultType_1.QosResultType.Failure] = 'Failure',
            _a[QosResultType_1.QosResultType.ExpectedFailure] = 'ExpectedFailure',
            _a);
        sp_core_library_2.Validate.isNonemptyString(scenarioName, 'scenarioName');
        this._id = sp_core_library_2.Guid.newGuid().toString();
        if (!this._isDebugSession()) {
            QosLogger_1.default.instance.startQosMonitor(this._id, { name: scenarioName });
        }
        this._scenarioName = scenarioName;
        this._hasEnded = false;
        this._copyToCosmos = copyToCosmos;
        this._copyToInterana = copyToInterana;
    }
    QosMonitor.startRealTimeProcessing = function () {
        if (!QosLogger_1.default.instance.shouldProcessInRealTime) {
            this._shouldProcessInRealTime(true);
        }
    };
    /**
     * Only used in unit tests
     * @internal
     */
    QosMonitor._shouldProcessInRealTime = function (processInRealTime) {
        QosLogger_1.default.instance.shouldProcessInRealTime = processInRealTime;
    };
    Object.defineProperty(QosMonitor.prototype, "name", {
        get: function () {
            return this._scenarioName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "shortEventName", {
        get: function () {
            return 'Qos';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "resultCode", {
        get: function () {
            return this._endResultCode;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "resultType", {
        get: function () {
            return this._endResult;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "extraData", {
        get: function () {
            return this._endExtraData;
        },
        set: function (value) {
            this._endExtraData = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QosMonitor.prototype, "hasEnded", {
        get: function () {
            return this._hasEnded;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * QoS monitor ends with success
     * You will see success tag: SPPages.ScenarioName.Success
     */
    // tslint:disable-next-line:no-any
    QosMonitor.prototype.writeSuccess = function (extraData) {
        this._writeQosEnd(QosResultType_1.QosResultType.Success, undefined, undefined, extraData);
    };
    /**
     * QoS monitor ends with failure
     * You will see failure tag: SPPages.ScenarioName.<failuretag>.Failure.
     * <failuretag> will be filled with param tagName
     */
    QosMonitor.prototype.writeUnexpectedFailure = function (tagNameSuffix, ex, extraData // tslint:disable-line:no-any
    ) {
        if (tagNameSuffix === void 0) { tagNameSuffix = 'DefaultUnexpected'; }
        this._writeQosEnd(QosResultType_1.QosResultType.Failure, tagNameSuffix, ex, extraData);
    };
    /*
     * QoS monitor ends with expected failure
     * You will see success tag: ModernPublish.RenderPublishPage.<failuretag>.ExpectedFailure.
     * <failuretag> will be filled with param tagName
     */
    QosMonitor.prototype.writeExpectedFailure = function (tagNameSuffix, ex, extraData // tslint:disable-line:no-any
    ) {
        if (tagNameSuffix === void 0) { tagNameSuffix = 'DefaultExpected'; }
        this._writeQosEnd(QosResultType_1.QosResultType.ExpectedFailure, tagNameSuffix, ex, extraData);
    };
    QosMonitor.prototype._writeQosEnd = function (resultType, tagNameSuffix, ex, extraData // tslint:disable-line:no-any
    ) {
        if (this._shouldSkip(resultType)) {
            return;
        }
        this._ensureCorrelationId(resultType, extraData);
        this._endResultCode = tagNameSuffix;
        this._endResult = resultType;
        var endData = {
            resultCode: this._endResultCode,
            resultType: this._endResult,
            error: ex ? ex.message : undefined,
            extraData: this._endExtraData
        };
        QosLogger_1.default.instance.writeQosEndResult(this._id, endData);
        this._writeToEngagement();
    };
    QosMonitor.prototype._ensureCorrelationId = function (resultType, extraData // tslint:disable-line:no-any
    ) {
        var _this = this;
        if (extraData) {
            this._ensureEndExtraData();
            // Instead of slower ...[spread], copy over the incoming values manually
            Object.keys(extraData).forEach(function (k) { return (_this._endExtraData[k] = extraData[k]); });
        }
        if (DiagnosticsSettingsManager_1.default.isInitialized && resultType !== QosResultType_1.QosResultType.Success) {
            var capitalKey = 'CorrelationId';
            var lowerKey = 'correlationId';
            var correlationId = ((this._endExtraData &&
                (this._endExtraData[capitalKey] || this._endExtraData[lowerKey])) ||
                DiagnosticsSettingsManager_1.default.settings.correlationId);
            if (correlationId) {
                if (!this._endExtraData) {
                    this._endExtraData = {};
                }
                this._endExtraData[capitalKey] = correlationId;
            }
        }
        this._logHostType();
    };
    QosMonitor.prototype._ensureEndExtraData = function () {
        if (!this._endExtraData) {
            this._endExtraData = {};
        }
    };
    /**
     * Logs the application hosted in Teams in combination with which Teams application it was hosted on.
     * Viva1p-TeamsNative: Viva home app loaded through Teams Desktop application, not including mobile
     * Viva1p-TeamsWeb: Viva home app loaded through Teams Web browser, not including mobile
     * MEEBridge-TeamsNative: VivaConnections MEEBridge app loaded through Teams mobile client.
     * ClassHome-TeamsNative: ClassHome app loaded through Teams Desktop application, not including mobile
     * ClassHome-TeamsWeb: ClassHome app loaded through Teams Web browser, not including mobile
     */
    QosMonitor.prototype._logHostType = function () {
        var _a;
        if (DiagnosticsSettingsManager_1.default.isInitialized) {
            var appHostType = void 0;
            if ((0, Killswitches_1.isLogTeamsAppTypeKSActivated)()) {
                var isMEEBridgeApplicationHosted = !(0, Killswitches_1.isLogVivaConnectionMobileAsAppHostTypeKSActivated)() &&
                    sp_core_library_1._BrowserUtilities.isMEEBridgeApplicationHosted();
                if (isMEEBridgeApplicationHosted || sp_core_library_1._BrowserUtilities.isTeamsHosted()) {
                    if (isMEEBridgeApplicationHosted) {
                        appHostType = 'MEEBridge';
                    }
                    else if (sp_core_library_1._BrowserUtilities.isViva1PHosted()) {
                        appHostType = 'Viva1p';
                    }
                    else if ((_a = DiagnosticsSettingsManager_1.default.settings.contextInfo) === null || _a === void 0 ? void 0 : _a.isEduClass) {
                        appHostType = 'ClassHome';
                    }
                    var teamsHostType = sp_core_library_1._BrowserUtilities.isTeamsBrowserHosted() ? 'TeamsWeb' : 'TeamsNative';
                    appHostType = appHostType ? "".concat(appHostType, "_").concat(teamsHostType) : teamsHostType;
                }
            }
            else {
                appHostType = sp_core_library_1._BrowserUtilities.getTeamsAppType();
            }
            // Skip logging for default SPO path for now to limit quota impact
            if (appHostType) {
                this._ensureEndExtraData();
                var hostKey = 'appHostType';
                // Unlikely, but avoid overwriting matching key value
                if (!this._endExtraData[hostKey]) {
                    this._endExtraData[hostKey] = appHostType;
                }
            }
        }
    };
    QosMonitor.prototype._isDebugSession = function () {
        return !!sessionStorage.getItem('spfx-debug');
    };
    QosMonitor.prototype._shouldSkip = function (result) {
        if (this._hasEnded && this._endResult !== undefined) {
            var message = sp_core_library_2.Text.format(QosMonitor.qosMonitorHasEndedErrorString, this.name, this._qosResultTypeValue[this._endResult], this._qosResultTypeValue[result]);
            if (this._endResult !== result) {
                TraceLogger_1.default.logError(QosMonitor.logSource, new Error(message));
            }
            if (DEBUG) {
                TraceLogger_1.default.logVerbose(QosMonitor.logSource, message, 'skipEnd');
            }
            return true;
        }
        else {
            this._hasEnded = true;
            return this._isDebugSession();
        }
    };
    QosMonitor.prototype._writeToEngagement = function () {
        if (this._copyToInterana) {
            EngagementLogger_1.default.log({
                name: this.name,
                extraData: this.extraData || {}
            });
        }
        if (this._copyToCosmos) {
            // Engagement name requires certain format. Cannot just use QOS name.
            // Record Qos name in extra data 'qosName'
            // tslint:disable-next-line:no-any
            var engagementData = {
                name: 'Spfx.Qos.ToEngagement',
                extraData: this.extraData || {}
            };
            // tslint:disable-next-line:no-string-literal
            engagementData.extraData['qosName'] = this.name;
            if (this.resultType) {
                // tslint:disable-next-line:no-string-literal
                engagementData.extraData['qosResultType'] = this._qosResultTypeValue[this.resultType];
            }
            if (this.resultCode) {
                // tslint:disable-next-line:no-string-literal
                engagementData.extraData['qosResultCode'] = this.resultCode;
            }
            EngagementLogger_1.default.log(engagementData);
        }
    };
    QosMonitor.logSource = {
        id: 'QosMonitor'
    };
    QosMonitor.qosMonitorHasEndedErrorString = "QoS monitor '{0}' has ended with '{1}' already. Ignoring '{2}' tag.";
    return QosMonitor;
}());
exports.default = QosMonitor;
//# sourceMappingURL=QosMonitor.js.map