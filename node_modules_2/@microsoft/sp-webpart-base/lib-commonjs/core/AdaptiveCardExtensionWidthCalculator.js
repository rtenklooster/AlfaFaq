"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdaptiveCardExtensionWidthCalculator = void 0;
/**
 * This class is used to shared card responsiveness logic between the AdaptiveCardExtensionWebPart and the canvas.
 * The goal is to maintain a grid layout at different screen / card container sizes that maximizes both card width
 * and how many cards can fit on a row.
 *
 * @internal
 */
var AdaptiveCardExtensionWidthCalculator = /** @class */ (function () {
    function AdaptiveCardExtensionWidthCalculator() {
        var _this = this;
        /**
         * Minimum width for the 'Medium' card size.
         */
        this.mediumCardMinWidth = 164;
        /**
         * Space between the cards, used to calculate large card size from medium card size.
         */
        this.cardSpacing = 16;
        /**
         * Map of the default card widths.
         */
        this.defaultCardWidthMap = {
            Medium: this.mediumCardMinWidth,
            Large: this.mediumCardMinWidth * 2 + this.cardSpacing
        };
        this.mediumCardMaxWidth = 204;
        this.mediumCardMinWidthSpacing = this.mediumCardMinWidth + this.cardSpacing;
        /**
         * The concept of breakpoints helps keep cards of different sizes on a grid layout
         * as they resize with their container while maximizing both card width
         * and how many cards can fit on a row.
         *
         * @param containerWidth - width of the container that houses the list of cards.
         * @param cardSize - adaptive card extension card size, 'Medium' or 'Large'.
         * @returns the calculated card width.
         */
        this.getCardWidthFromBreakpoint = function (containerWidth, cardSize) {
            var minCardWidth = _this.getCardWidthFromSize(_this.mediumCardMinWidth, cardSize);
            var availableCardWidth;
            if (containerWidth >= _this._getCardBreakpoint(6)) {
                return _this._getMaximizedCardWidth(Math.floor(containerWidth / 6 - _this.cardSpacing), cardSize);
            }
            if (containerWidth >= _this._getCardBreakpoint(5)) {
                availableCardWidth = Math.floor(containerWidth / 5 - _this.cardSpacing);
                return _this._getMaximizedCardWidth(availableCardWidth, cardSize);
            }
            if (containerWidth >= _this._getCardBreakpoint(4)) {
                availableCardWidth = Math.floor(containerWidth / 4 - _this.cardSpacing);
                return _this._getMaximizedCardWidth(availableCardWidth, cardSize);
            }
            if (containerWidth >= _this._getCardBreakpoint(3)) {
                availableCardWidth = Math.floor(containerWidth / 3 - _this.cardSpacing);
                return _this._getMaximizedCardWidth(availableCardWidth, cardSize);
            }
            if (containerWidth >= _this._getCardBreakpoint(2)) {
                availableCardWidth = Math.floor(containerWidth / 2 - _this.cardSpacing);
                return _this._getMaximizedCardWidth(availableCardWidth, cardSize);
            }
            return minCardWidth;
        };
        /**
         * Uses the defined card size to determine the card width. Medium cards have set min and max widths
         * while Large card width is calculated based the Medium card size to maintain the grid layout.
         *
         * @param mediumCardWidth - the current width of the Medium card size.
         * @param cardSize - the card size of the current card, Medium or Large.
         * @returns the card width.
         */
        this.getCardWidthFromSize = function (mediumCardWidth, cardSize) {
            return cardSize === 'Large' ? mediumCardWidth * 2 + _this.cardSpacing : mediumCardWidth;
        };
        /**
         * This function is specifically used for cards inside dashboard web part.
         * When dashboard web part is on a vertical column, there exists an edge case where a
         * minimum width large card (2 medium cards with spacers) cannot fit in the container.
         * If that is the case we reduce the minimum size of the cards such that at least two medium cards can fit.
         *
         * If a minimum sized large card can fit in the container, optimize for grid layout and card size.
         * Refer to getCardWidthFromBreakpoint function above.
         * @param containerWidth - width of the container that houses the list of cards.
         * @returns - ICardSizeWidths - contains both medium and large card widths.
         */
        this.getDashboardCardWidthsFromContainer = function (containerWidth) {
            var minLargeCardWidth = _this.mediumCardMinWidth * 2 + _this.cardSpacing;
            if (containerWidth < minLargeCardWidth) {
                var newMinMediumCardWidth = Math.floor(containerWidth / 2 - _this.cardSpacing / 2);
                return {
                    Medium: newMinMediumCardWidth,
                    Large: _this.getCardWidthFromSize(newMinMediumCardWidth, 'Large')
                };
            }
            var mediumCardWidth = _this.getCardWidthFromBreakpoint(containerWidth, 'Medium');
            return {
                Medium: mediumCardWidth,
                Large: _this.getCardWidthFromSize(mediumCardWidth, 'Large')
            };
        };
        this._getCardBreakpoint = function (cardCount) {
            return _this.mediumCardMinWidthSpacing * cardCount;
        };
    }
    AdaptiveCardExtensionWidthCalculator.prototype._getMaximizedCardWidth = function (availableCardSpace, cardSize) {
        var maximizedMediumCardWidth = Math.min(Math.max(availableCardSpace, this.mediumCardMinWidth), this.mediumCardMaxWidth);
        return this.getCardWidthFromSize(maximizedMediumCardWidth, cardSize);
    };
    return AdaptiveCardExtensionWidthCalculator;
}());
exports.AdaptiveCardExtensionWidthCalculator = AdaptiveCardExtensionWidthCalculator;
//# sourceMappingURL=AdaptiveCardExtensionWidthCalculator.js.map